!function () {
    "use strict";
    function idw_reg(canvas) {
        if (!(this instanceof idw_reg))
            return new idw_reg(canvas);

        //if canvas is still string, retrieve element
        this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
        this._context = canvas.getContext('2d');
        this._width = canvas.width;
        this._height = canvas.height;
        this._max = 1;

        // data storage
        this._data = [];
    }
    // idw object definition
    idw_reg.prototype = {
        defaultCellSize: 25,
        defaultGradient: {
            0.0: '#031086', //blue
            0.1: '#353f9e',
            0.2: '#676fb6',
            0.3: '#949fce',
            0.4: '#cccfe6',
            0.5: '#ffffff', //white
            0.6: '#eccdcc',
            0.7: '#d99b99',
            0.8: '#c76a66',
            0.9: '#b43833',
            1.0: '#a20701' //red
        },
        data: function (data) {
            this._data = data;
            return this;
        },
        max: function (max) {
            this._max = max;
            return this;
        },
        add: function (point) {
            this._data.push(point);
            return this;
        },
        clear: function () {
            this._data = [];
            return this;
        },
        cellSize: function (cs) {
            // create cell context
            var cell = this._cell = document.createElement("canvas"),
                    context = cell.getContext('2d');
            this._cs = cs;

            // square cells
            cell.width = cell.height = cs;

            // draw cell
            context.beginPath();
            context.rect(0, 0, cs, cs);
            context.fill();
            context.closePath();

            return this;
        },
        resize: function () {
            this._width = this._canvas.width;
            this._height = this._canvas.height;
        },
        gradient: function (grad) {
            // context for referencing grayscale alpha when determining colour
            var canvas = document.createElement("canvas"),
                    context = canvas.getContext('2d'),
                    gradient = context.createLinearGradient(0, 0, 0, 256);

            // linear collection of pixels of gradient's scalar colour valies
            canvas.width = 1;
            canvas.height = 256;

            // for each value in grad input, set context gradient pixel of respective colour
            for (var i in grad) {
                gradient.addColorStop(+i, grad[i]);
            }

            context.fillStyle = gradient;
            context.fillRect(0, 0, 1, 256);

            // get array of RGBA values generated by gradient context;
            this._grad = context.getImageData(0, 0, 1, 256).data;
            //console.log("GRADIANT SIZE " + this._grad.length);

            return this;
        },
        draw: function (opacity) {
            // if cells and grads not already instantiated, generate default
            if (!this._cell)
                this.cellSize(this.defaultCellSize);
            if (!this._grad)
                this.gradient(this.defaultGradient);

            // reset screen
            var context = this._context;
            context.clearRect(0, 0, this._width, this._height);

            // DATA <- [ X , Y , VALUE ] 

            // draws a cell at each data point
            for (var i = 0, len = this._data.length, curr; i < len; i++) {
                curr = this._data[i];
                context.globalAlpha = curr[2] / this._max;
                // sets x and y to corresponding upper-left origin point and draws cell
                context.drawImage(this._cell, curr[0] - this._cs, curr[1] - this._cs);
            }

            // match opacity to colour value from gradient context
            var coloured = context.getImageData(0, 0, this._width, this._height);
            this._colourize(coloured.data, this._grad, opacity);
            context.putImageData(coloured, 0, 0);

            return this;
        },

        _colourize: function (pixels, gradient, opacity) {
            for (var i = 0, len = pixels.length, curr; i < len; i += 4) {
                curr = pixels[i + 3] * 4;
                pixels[i] = gradient[curr];
                pixels[i + 1] = gradient[curr + 1];
                pixels[i + 2] = gradient[curr + 2];
                pixels[i + 3] = opacity * 256;
            }
        }

    }, window.idw_reg = idw_reg;

}(),
        L.RegressionLayer = (L.Layer ? L.Layer : L.Class).extend({
    initialize: function (multiIdws, options) {
        this._multiIdws = multiIdws;
        L.setOptions(this, options);
    },
    setOptions: function (options) {
        L.setOptions(this, options);
        if (this._idw) {
            this._updateOptions();
        }
        return this.redraw();
    },
    redraw: function () {
        if (this._idw && !this._frame && !this._map._animating) {
            this._frame = L.Util.requestAnimFrame(this._redraw, this);
        }
        return this;
    },
    onAdd: function (map) {
        this._map = map;
        if (!this._canvas) {
            this._initCanvas();
        }
        map._panes.overlayPane.appendChild(this._canvas);
        map.on('moveend', this._reset, this);
        if (map.options.zoomAnimation && L.Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }
        this._reset();
    },
    onRemove: function (map) {
        map.getPanes().overlayPane.removeChild(this._canvas);
        map.off('moveend', this._reset, this);
        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }
    },
    addTo: function (map) {
        map.addLayer(this);
        return this;
    },
    _initCanvas: function () {
        var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-idw-layer leaflet-layer');
        var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
        canvas.style[originProp] = '50% 50%';
        var size = this._map.getSize();
        canvas.width = size.x;
        canvas.height = size.y;
        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
        this._idw = idw_reg(canvas);
        this._updateOptions();
    },
    _updateOptions: function () {
        this._idw.cellSize(this.options.cellSize || this._idw.defaultCellSize);
        if (this.options.gradient) {
            this._idw.gradient(this.options.gradient);
        }
        if (this.options.max) {
            this._idw.max(this.options.max);
        }
    },
    _reset: function () {
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        L.DomUtil.setPosition(this._canvas, topLeft);
        var size = this._map.getSize();
        if (this._idw._width !== size.x) {
            this._canvas.width = this._idw._width = size.x;
        }
        if (this._idw._height !== size.y) {
            this._canvas.height = this._idw._height = size.y;
        }
        this._redraw();
    },
    _calculateRegressionData() {
        // container for pixel storage after calculation
        var data = [];

        // get pixel data from interpolation
        var packages = [];
        for (var i = 0; i < this._multiIdws.length; i++) {
            packages[i] = this._multiIdws[i].accessData(this._map);
        }
        // size of a single package, number of pixels to loop through
        var packageSize = packages[0].length;

        // tracker variables for minimum and maximum linear regressions
        var lrMin, lrMax, linReg;

        // main loop to iterate through pixel
        for (var i = 0; i < packageSize; i++) {

            var xunits = []; // x axis variable for lr calculation
            var yunits = []; // y axis variables for lr calculation
            for (var j = 0; j < packages.length; j++) {
                // time dimension temporarily sequencial
                xunits[j] = j;
                // quantity dimension taken from each package/pixel/interpolated value
                yunits[j] = packages[j][i][2];
            }

            // each pixel analysis compiled into its own array
            var dataUnit = [];
            // pixel x and y coordinate taken from package to maintain proportional cell placement
            dataUnit[0] = packages[0][i][0];
            dataUnit[1] = packages[0][i][1];

            // linear regression returns slope of best fit line as new value for current pixel
            linReg = linearRegression(xunits, yunits);
            dataUnit[2] = linReg;

            // store new pixel object in pixel container
            data[i] = dataUnit;
            // initialize min, max and temp value at beginning of loop
            if (i === 0) {
                lrMin = lrMax = linReg;
            } else if (i > 0) {
                //swap out if smaller than current min
                if (linReg < lrMin) {
                    lrMin = linReg;
                }
                // swap out if larger than current max
                if (linReg > lrMax) {
                    lrMax = linReg;
                }
            }

        }

        if (Math.abs(lrMax) > Math.abs(lrMin)) {
            lrMin = 0 - lrMax;
        } else {
            lrMax = 0 - lrMin;
        }

        // calculate new range to scale gradient
        var range = lrMax - lrMin;

        // set range total to max for gradient scaling
        this._idw.max(range);

        // shift value range to avoid negatives
        for (var i = 0; i < data.length; i++) {
            data[i][2] += (0 - lrMin);
        }

        return data;
    },
    _redraw: function () {
        if (!this._map) {
            return;
        }
        var data = this._calculateRegressionData();
        if (data !== null) {
            this._idw.data(data).draw(this.options.opacity);
        }
        this._frame = null;
    },
    _animateZoom: function (e) {
        var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        if (L.DomUtil.setTransform) {
            L.DomUtil.setTransform(this._canvas, offset, scale);

        } else {
            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
        }
    },

    // Returns linear regression best-fit slope at event layerPoint 'co'
    getValue: function (co) {
        var size = this._map.getSize(),
                x = co.x, 
                y = co.y, 
                s = this._idw._cs,
                bounds = new L.Bounds(L.point([-s, -s]), size.add([s, s])),
                w = (Math.ceil((bounds.max.x - bounds.min.x) / s) + 1), 
                h = (Math.ceil((bounds.max.y - bounds.min.y) / s) + 1),
                nX = (Math.ceil((x - bounds.min.x) / s) + 1),
                nY = (Math.ceil((y - bounds.min.y) / s) + 1),
                idx = (nY * w) + nX;

        return (this._idw._data[idx][2])-((this._idw._max)/2);
    }

});
L.regressionLayer = function (multiIdws, options) {
    return new L.RegressionLayer(multiIdws, options);
};