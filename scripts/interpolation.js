/*
 Fully based on Leaflet.idw, inverse distance weight plugin by Joran Beaufort
 https://github.com/JoranBeaufort/Leaflet.idw
 version: 0.0.2
*/
!function () {
    "use strict";
    function idw(canvas) {
        //console.log("==  creating idw  ==");
        if (!(this instanceof idw))
            return new idw(canvas);

        //if canvas is still string, retrieve element
        this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;
        this._context = canvas.getContext('2d');
        this._width = canvas.width;
        this._height = canvas.height;
        this._max = 1;

        // data storage
        this._data = [];
    }
    // idw object definition
    idw.prototype = {
        defaultCellSize: 25,
        defaultGradient: {
            0.0: '#ffffff', //white
            0.1: '#f5e5e5',
            0.2: '#ebcccc',
            0.3: '#e2b3b3',
            0.4: '#d89a9a',
            0.5: '#cf8181',
            0.6: '#c56868',
            0.7: '#bb4f4f',
            0.8: '#b23636',
            0.9: '#a81d1d',
            1.0: '#9f0404' //red
        },
        data: function (data) {
            this._data = data;
            return this;
        },
        max: function (max) {
            this._max = max;
            return this;
        },
        add: function (point) {
            this._data.push(point);
            return this;
        },
        clear: function () {
            this._data = [];
            return this;
        },
        cellSize: function (cs) {
            // create cell context
            var cell = this._cell = document.createElement("canvas"),
                    context = cell.getContext('2d');
            this._cs = cs;

            // square cells
            cell.width = cell.height = cs;

            // draw cell
            context.beginPath();
            context.rect(0, 0, cs, cs);
            context.fill();
            context.closePath();

            return this;
        },
        resize: function () {
            this._width = this._canvas.width;
            this._height = this._canvas.height;
        },
        gradient: function (grad) {
            // context for referencing grayscale alpha when determining colour
            var canvas = document.createElement("canvas"),
                    context = canvas.getContext('2d'),
                    gradient = context.createLinearGradient(0, 0, 0, 256);

            // linear collection of pixels of gradient's scalar colour valies
            canvas.width = 1;
            canvas.height = 256;

            // for each value in grad input, set context gradient pixel of respective colour
            for (var i in grad) {
                gradient.addColorStop(+i, grad[i]);
            }

            context.fillStyle = gradient;
            context.fillRect(0, 0, 1, 256);

            // get array of RGBA values generated by gradient context;
            this._grad = context.getImageData(0, 0, 1, 256).data;

            return this;
        },
        draw: function (opacity) {
            // if cells and grads not already instantiated, generate default
            if (!this._cell)
                this.cellSize(this.defaultCellSize);
            if (!this._grad)
                this.gradient(this.defaultGradient);

            // reset screen
            var context = this._context;
            context.clearRect(0, 0, this._width, this._height);

            // DATA <- [ X , Y , VALUE ] 

            // draws a cell at each data point
            for (var i = 0, len = this._data.length, curr; i < len; i++) {
                curr = this._data[i];
                context.globalAlpha = curr[2] / this._max;
                // sets x and y to corresponding upper-left origin point and draws cell
                context.drawImage(this._cell, curr[0] - this._cs, curr[1] - this._cs);
            }

            // match opacity to colour value from gradient context
            var coloured = context.getImageData(0, 0, this._width, this._height);
            this._colourize(coloured.data, this._grad, opacity);

            context.putImageData(coloured, 0, 0);
            return this;

        },
        _colourize: function (pixels, gradient, opacity) {
            for (var i = 0, len = pixels.length, curr; i < len; i += 4) {
                curr = pixels[i + 3] * 4;
                pixels[i] = gradient[curr];
            }
        },

    }, window.idw = idw;
}(),
        L.IdwLayer = (L.Layer ? L.Layer : L.Class).extend({

//    options: {
//        opacity: 0.5,
//        maxZoom: 18,
//        cellSize: 1,
//        exp: 2,
//        max: 100
//    },
    initialize: function (latlngs, options) {
//        console.log("===  initialize  ===");
        this._latlngs = latlngs;
        L.setOptions(this, options);
    },

    setLatLngs: function (latlngs) {
        //console.log("===  setLatLng  ===");
        this._latlngs = latlngs;
        return this.redraw();
    },

    addLatLng: function (latlng) {
        //console.log("===  addLatLng  ===");
        this._latlngs.push(latlng);
        return this.redraw();
    },
    setOptions: function (options) {
        //console.log("===  setOptions  ===");
        L.setOptions(this, options);
        if (this._idw) {
            this._updateOptions();
        }
        return this.redraw();
    },
    redraw: function () {
//        console.log("===  redraw  ===");
        if (this._idw && !this._frame && !this._map._animating) {
            this._frame = L.Util.requestAnimFrame(this._redraw, this);
        }
        return this;
    },
    onAdd: function (map) {
//        console.log("===  onAdd  ===");
        this._map = map;
        if (!this._canvas) {
            this._initCanvas();
        }
        map._panes.overlayPane.appendChild(this._canvas);
        map.on('moveend', this._reset, this);
        if (map.options.zoomAnimation && L.Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }
        this._reset();
    },
    onRemove: function (map) {
//        console.log("===  onRemove  ===");
        map.getPanes().overlayPane.removeChild(this._canvas);
        map.off('moveend', this._reset, this);
        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }
    },
    addTo: function (map) {
//        console.log("===  addTo  ===");
        map.addLayer(this);
        return this;
    },
    _initCanvas: function () {
//        console.log("===  _initCanvas  ===");
        var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-idw-layer leaflet-layer');
        var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
        canvas.style[originProp] = '50% 50%';
        var size = this._map.getSize();
        canvas.width = size.x;
        canvas.height = size.y;
        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
        this._idw = idw(canvas);
        this._updateOptions();
    },
    _updateOptions: function () {
//        console.log("===  _updateOptions  ===");
        this._idw.cellSize(this.options.cellSize || this._idw.defaultCellSize);
        if (this.options.gradient) {
            this._idw.gradient(this.options.gradient);
        }
        if (this.options.max) {
            this._idw.max(this.options.max);
        }
    },
    _reset: function () {
//        console.log("===  _reset  ===");
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
        L.DomUtil.setPosition(this._canvas, topLeft);
        var size = this._map.getSize();
        if (this._idw._width !== size.x) {
            this._canvas.width = this._idw._width = size.x;
        }
        if (this._idw._height !== size.y) {
            this._canvas.height = this._idw._height = size.y;
        }
        this._redraw();
    },
    _calculateData() {
//        console.log("===  _calculateData  ===");
        var data = [],
                // cell size
                cs = this._idw._cs,
                // number of pixels in map container        
                size = this._map.getSize(),
                // rectangular area of pixel rendering    
                bounds = new L.Bounds(L.point([-cs, -cs]), size.add([cs, cs])),
                // expansion scalar
                exp = this.options.exp === undefined ? 1 : this.options.exp,
                // maximum magnitude
                max = this.options.max === undefined ? 1 : this.options.max,
                // maximum zoom level
                //maxZoom = this.options.maxZoom === undefined ? this._map.getMaxZoom() : this.options.maxZoom,
                //v = 1,
                // center dimensions of a cell
                cellCen = cs / 2,
                //grid = [],
                // width in number of cells
                nCellX = Math.ceil((bounds.max.x - bounds.min.x) / cs) + 1,
                //height in number of cells
                nCellY = Math.ceil((bounds.max.y - bounds.min.y) / cs) + 1,
                i, len, p, cell, x, y, j, len2, k;

//          console.log("Xcells: "+nCellX+ "    Ycells: "+nCellY);
//        console.log("width in cells: " + nCellX);
//        console.log("height in cells: " + nCellY);
//        console.log("SIZE: "+size);
        // loop to set each pixel
        for (i = 0, len = nCellY; i < len; i++) {
            for (j = 0, len2 = nCellX; j < len2; j++) {
                // current x,y coordinates
                var x = i * cs, y = j * cs;
                var numerator = 0, denominator = 0;

                // loop through all latlngs points to calculate current pixel data
                for (k = 0, len3 = this._latlngs.length; k < len3; k++) {
                    // get pixel coordinate from current latlng
                    var p = this._map.latLngToContainerPoint(this._latlngs[k]);
                    // calculate center of current pixel
                    var cp = L.point((y - cellCen), (x - cellCen));
                    // calculate distance between current pixel and current coordinate
                    var dist = cp.distanceTo(p);
                    // get the magnitude of current point
                    var val = this._latlngs[k].alt !== undefined ? this._latlngs[k].alt :
                            this._latlngs[k][2] !== undefined ? +this._latlngs[k][2] : 1;
                    // can't divide by 0
                    if (dist === 0) {
                        numerator = val;
                        denominator = 1;
                        break;
                    }

                    // distance to power of expansion distance
                    var dist2 = Math.pow(dist, exp);
                    var toNum, toDen;
                    toNum = (val / dist2);
                    toDen = (1 / dist2);

                    // magnitude of current latlng divided by distance to current pixel
                    numerator += toNum;
                    // smoothes interpolated surface
                    denominator += toDen;
                }

                // idw calculation
                interpolVal = numerator / denominator;

                // build cell coordinates
                cell = [j * cs, i * cs, interpolVal];

                // adds cell values to data container
                if (cell) {
                    data.push([
                        Math.round(cell[0]),
                        Math.round(cell[1]),
                        Math.min(cell[2], max)
                    ]);
                }
            }
        }
        return data;
    },
    _redraw: function () {
//        console.log("===  _redraw  ===");

        if (!this._map) {
            return;
        }

        this._idw.data(this._calculateData());
        this._idw.draw(this.options.opacity);

        this._frame = null;
    },
    _animateZoom: function (e) {
        var scale = this._map.getZoomScale(e.zoom),
                offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        if (L.DomUtil.setTransform) {
            L.DomUtil.setTransform(this._canvas, offset, scale);

        } else {
            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
        }
    },
    accessData: function (map) {
        this._map = map;
        if (!this._canvas) {
            this._initCanvas();
        }
        this._idw.data(this._calculateData());
        return this._idw._data;
    }
});

L.idwLayer = function (latlngs, options) {
    //console.log("idwLayer called");
    return new L.IdwLayer(latlngs, options);
};